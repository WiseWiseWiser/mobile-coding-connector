package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/xhd2015/less-gen/flags"
)

const (
	suffix = ".orig"
)

var commands = []string{"kill", "pkill", "killall"}

const help = `
Usage: shad-kill [options]

Install wrapper scripts for kill/pkill/killall that block execution in agent mode.

Options:
  --dry-run    Show what would be done without making changes
  --undo       Restore original binaries
  -h, --help  Show this help message
`

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	dryRun := false
	undo := false

	args, err := flags.
		Bool("--dry-run", &dryRun).
		Bool("--undo", &undo).
		Help("-h,--help", help).
		Parse(os.Args[1:])
	if err != nil {
		return err
	}

	if len(args) > 0 {
		return fmt.Errorf("unrecognized args: %s", strings.Join(args, " "))
	}

	if dryRun {
		fmt.Println("[DRY RUN] Would perform the following actions:")
	}

	if undo {
		return undoWithDryRun(dryRun)
	}

	return installWithDryRun(dryRun)
}

func installWithDryRun(dryRun bool) error {
	installed := true
	for _, cmd := range commands {
		path, err := exec.LookPath(cmd)
		if err != nil {
			installed = false
			break
		}
		if !isWrapper(path) {
			installed = false
			break
		}
	}

	if installed {
		fmt.Println("shad-kill is already installed. Run with --undo to restore original binaries.")
		return nil
	}

	if !dryRun {
		fmt.Println("Installing shad-kill...")
	}

	for _, cmd := range commands {
		err := replaceCommand(cmd, dryRun)
		if err != nil {
			if dryRun {
				fmt.Printf("  ERROR: %v\n", err)
			} else {
				fmt.Fprintf(os.Stderr, "Failed to replace %s: %v\n", cmd, err)
			}
			continue
		}
		if dryRun {
			fmt.Printf("  Replace: %s\n", cmd)
		} else {
			fmt.Printf("Replaced: %s\n", cmd)
		}
	}

	if dryRun {
		fmt.Println("\n[DRY RUN] Would complete installation.")
	} else {
		fmt.Println("\nDone! Kill commands are now intercepted in agent mode.")
		fmt.Println("To restore original binaries, run: shad-kill --undo")
	}
	return nil
}

func undoWithDryRun(dryRun bool) error {
	if !dryRun {
		fmt.Println("Restoring original binaries...")
	}

	for _, cmd := range commands {
		err := restoreCommand(cmd, dryRun)
		if err != nil {
			if dryRun {
				fmt.Printf("  ERROR: %v\n", err)
			} else {
				fmt.Fprintf(os.Stderr, "Failed to restore %s: %v\n", cmd, err)
			}
			continue
		}
		if dryRun {
			fmt.Printf("  Restore: %s\n", cmd)
		} else {
			fmt.Printf("Restored: %s\n", cmd)
		}
	}

	if dryRun {
		fmt.Println("\n[DRY RUN] Would restore original binaries.")
	} else {
		fmt.Println("Done!")
	}
	return nil
}

func replaceCommand(cmd string, dryRun bool) error {
	path, err := exec.LookPath(cmd)
	if err != nil {
		return fmt.Errorf("%s not found in PATH", cmd)
	}

	absPath, err := filepath.Abs(path)
	if err != nil {
		return err
	}

	// Check if already replaced first (before isTextFile since our wrapper is also text)
	if isWrapper(absPath) {
		return fmt.Errorf("skipped: %s already replaced", cmd)
	}

	if isTextFile(absPath) {
		return fmt.Errorf("skipped: %s is a text file", cmd)
	}

	if dryRun {
		return nil
	}

	origPath := absPath + suffix
	if err := os.Rename(absPath, origPath); err != nil {
		return err
	}

	wrapper := getWrapperScript(origPath)
	if err := os.WriteFile(absPath, []byte(wrapper), 0755); err != nil {
		os.Rename(origPath, absPath)
		return err
	}

	return nil
}

func restoreCommand(cmd string, dryRun bool) error {
	possiblePaths := []string{
		"/bin/" + cmd,
		"/usr/bin/" + cmd,
		"/sbin/" + cmd,
		"/usr/sbin/" + cmd,
	}

	var absPath string
	for _, p := range possiblePaths {
		if _, err := os.Stat(p); err == nil {
			absPath = p
			break
		}
	}

	if absPath == "" {
		return fmt.Errorf("%s not found in standard paths", cmd)
	}

	if !isWrapper(absPath) {
		return fmt.Errorf("skipped: %s not a wrapper", cmd)
	}

	if dryRun {
		return nil
	}

	origPath := absPath + suffix
	if _, err := os.Stat(origPath); err != nil {
		return fmt.Errorf("original %s not found", origPath)
	}

	if err := os.Remove(absPath); err != nil {
		return err
	}

	if err := os.Rename(origPath, absPath); err != nil {
		return err
	}

	return nil
}

func isTextFile(path string) bool {
	// Try to read first few bytes to check if it's text
	file, err := os.Open(path)
	if err != nil {
		return false
	}
	defer file.Close()

	buf := make([]byte, 512)
	n, err := file.Read(buf)
	if err != nil {
		return false
	}

	// Check for null bytes (binary indicator)
	for i := 0; i < n; i++ {
		if buf[i] == 0 {
			return false
		}
	}

	// Check if it's a shell script (starts with #!)
	if n >= 2 && buf[0] == '#' && buf[1] == '!' {
		return true
	}

	return true // Assume text if no nulls and valid
}

func isWrapper(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	return strings.Contains(string(data), "SHAD_KILL_ORIG") ||
		strings.Contains(string(data), "Auto-generated by shad-kill")
}

func getWrapperScript(origPath string) string {
	return fmt.Sprintf(`#!/bin/sh
# Auto-generated by shad-kill - DO NOT EDIT
# SHAD_KILL_ORIG: %s

# Check if running in agent mode
if [ -n "$AGENT" ] || [ -n "$OPENCODE" ]; then
    echo "Blocked: kill command not allowed in agent mode" >&2
    exit 1
fi

# Fall through to original binary
exec %s "$@"
`, origPath, origPath)
}
