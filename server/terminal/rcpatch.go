package terminal

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// rcPatchOptions holds the options for building a custom shell RC file.
type rcPatchOptions struct {
	ExtraPaths []string
	PS1        string
}

// buildPatchLines builds the export lines for the given options.
func buildPatchLines(opts rcPatchOptions) string {
	var lines []string
	if len(opts.ExtraPaths) > 0 {
		lines = append(lines, fmt.Sprintf("export PATH=$PATH:%s", strings.Join(opts.ExtraPaths, ":")))
	}
	if opts.PS1 != "" {
		lines = append(lines, fmt.Sprintf("export PS1=%s", ShellQuote(opts.PS1)))
	}
	return strings.Join(lines, "\n")
}

// writeCustomBashRC writes a custom bash RC file at ~/.ai-critic-bashrc
// that sources the user's original bash profile/rc files and then applies
// ai-critic customizations. Returns the path to the custom file.
func writeCustomBashRC(opts rcPatchOptions) (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("get home dir: %w", err)
	}

	rcPath := filepath.Join(home, ".ai-critic-bashrc")

	// Source the user's original files in the same order bash --login would
	var sources []string
	for _, f := range []string{".bash_profile", ".bashrc", ".profile"} {
		p := filepath.Join(home, f)
		if _, err := os.Stat(p); err == nil {
			sources = append(sources, fmt.Sprintf("[ -f %s ] && . %s", ShellQuote(p), ShellQuote(p)))
		}
	}

	patchLines := buildPatchLines(opts)

	var content strings.Builder
	content.WriteString("# Auto-generated by ai-critic. Do not edit.\n")
	for _, s := range sources {
		content.WriteString(s + "\n")
	}
	if patchLines != "" {
		content.WriteString("\n# ai-critic customizations\n")
		content.WriteString(patchLines + "\n")
	}

	if err := os.WriteFile(rcPath, []byte(content.String()), 0644); err != nil {
		return "", fmt.Errorf("write %s: %w", rcPath, err)
	}
	return rcPath, nil
}

// writeCustomZshRC writes a custom zsh RC directory at ~/.ai-critic-zsh/
// containing a .zshrc that sources the user's original ~/.zshrc and then
// applies ai-critic customizations. Returns the path to the custom ZDOTDIR.
func writeCustomZshRC(opts rcPatchOptions) (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("get home dir: %w", err)
	}

	zdotdir := filepath.Join(home, ".ai-critic-zsh")
	if err := os.MkdirAll(zdotdir, 0755); err != nil {
		return "", fmt.Errorf("mkdir %s: %w", zdotdir, err)
	}

	rcPath := filepath.Join(zdotdir, ".zshrc")

	// Source the user's original .zshrc
	origZshrc := filepath.Join(home, ".zshrc")
	patchLines := buildPatchLines(opts)

	var content strings.Builder
	content.WriteString("# Auto-generated by ai-critic. Do not edit.\n")
	if _, err := os.Stat(origZshrc); err == nil {
		content.WriteString(fmt.Sprintf("[ -f %s ] && . %s\n", ShellQuote(origZshrc), ShellQuote(origZshrc)))
	}
	if patchLines != "" {
		content.WriteString("\n# ai-critic customizations\n")
		content.WriteString(patchLines + "\n")
	}

	if err := os.WriteFile(rcPath, []byte(content.String()), 0644); err != nil {
		return "", fmt.Errorf("write %s: %w", rcPath, err)
	}
	return zdotdir, nil
}
